\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\topmargin0.0cm
\headheight0.0cm
\headsep0.0cm
\oddsidemargin0.0cm
\textheight23.0cm
\textwidth16.5cm
\footskip1.0cm

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\makeatletter
\def\and{%
  \end{tabular}%
  \hskip 0.0001em \@plus.17fil\relax
  \begin{tabular}[t]{c}}

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\begin{document}

\title{\textbf{WACC 20: Reflection and Extension} \\ Imperial College London \\ Autumn}
\author{
  Paul Li\'etar\\
  \texttt{pl2113}
  \and
  Leanne Lyons\\
  \texttt{ll5914}
  \and
  Jaime Rodr\'iguez\\
  \texttt{jr1314}
  \and
  Ignacio Navarro\\
  \texttt{in714}
}
\date{}

\maketitle

\section{Product}
Analysis and critical evaluation of the quality of WACC.

\section{Project Management}
\subsection{Organisation}
The organisation of our group got better and smoother as the project advanced. At the beginning the division of the Frontend was between the three parts: lexer, 
parser, and semantic checker. However, we weren't fully aware that each were not equivalent in terms of work, so for example the team members that worked on the parser worked harder than the ones that worked on the lexer. However we changed that on the Backend. Although inevitably we couldn't all contribute to the Backend in the same degree (as the expertise of some team members were far beyond others), we did know how to push each of the team members to work their hardest on each assignment. By the start of the extension, we were all on the same page and very organised. We decided to part ways on the extension and assigned a particular extension to each team member according to our level. This made the extension part of the project very pleasant to work on, as each team member had 
free room to play around but forced to learn more from the code written by others, since most extensions need the team member to modify many files. Hence Paul worked on concurrency and register spilling, Jaime worked on garbage collection, Ignacio worked on extending pairs to tuples, and Leanne improved the if statements, adding a switch statement. 
\subsection{Use of Git}
As our organisation, our use of git got better as the project advanced. Paul's  knowledge of git helped the other team members become very fluent with git, which helped the project get very smooth. We branched the project accordingly to the necessary division at each milestone. Finally, for the extension we created four branches so that each team member could experiment. Without doubt this project has helped become much more acquainted with Git than any other small lab project.

\subsection{Communication}
The communication in our group was excellent from the beginning to the end. The use of chat groups on our phone was enough to have details of the project, meeting times, divide tasks, and help each other out whenever was necessary.  

\section{Design Choices}
Design patterns used and design choices made throughout the project.



\section{Extensions}
\subsection{Register Spilling}
\subsection{Concurrency}
\subsection{Garbage Collection}
\subsection{Improving If Statements}
\subsection{Extending Pairs to Tuples}
One limited feature of WACC was the ability to deal with pairs instead of arbitrarily sized tuples. So a nice extension was to expand WACC to support tuples. The first step in this extension was to control the would-be redundancy if we kept all the code handling pairs and creating new code for tuples. So what was done was to naturally consider pairs as a subset of tuples. The only difference in code then would be on the lexer and the parser, but from the parser on we considered pairs as tuples and we only wrote code regarding tuples. The only problem then was accessing a pair with \texttt{fst} and \texttt{snd}. We made the decision that tuples were to be accesed in the same manner as arrays (i.e. \texttt{a[1]}), so then it  was an easy fix as we just considered \texttt{fst p = p[0]} and \texttt{snd p = p[1]}.

\begin{lstlisting}
begin
  int[] arr = [1,2,4,5];
  tuple(int, bool, char, int[]) tup = newtuple(1, false, 'c', arr);
  println tup[0]; # Prints 1.
  println tup[3][2] # Prints 4.
end
\end{lstlisting}

The second problem we encountered was that now arrays and tuples are accessed in the same manner. However, tuples can only be accesed with literal integers (so
then \texttt{int b = 2; println tup[b]} is ilegal but \texttt{int b = 2; println tup[2]} is legal in our extension) while arrays can be indexed with expressions. So we changed our design of arrays and merged the two into an IndexingElem instead of having TupleElem and ArrayElem. This helped solved the problem because now it was a matter of just pattern matching in the appropiate moment as we always carry around the type of the IndexingElem; either a tuple or an array.

\subsection{Future extensions}

\end{document}
